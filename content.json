[{"title":"使用node搭建HTTPS服务","date":"2017-06-22T02:30:19.000Z","path":"2017/06/22/使用node搭建HTTPS服务/","text":"HTTPS 理论1.对HTTPS 原理 前面已经讲过，不在赘述: HTTPS原文链接 2. 数字证书 是一种用于电脑的身份识别机制。由数字证书颁发机构（CA）对使用私钥创建的签名请求文件做的签名（盖章），表示CA结构对证书持有者的认可。 证书优点： 1 使用数字证书能够提高用户的可信度 2 数字证书中的公钥，能够与服务端的私钥配对使用，实现数据传输过程中的加密和解密 3 在证认使用者身份期间，使用者的敏感个人数据并不会被传输至证书持有者的网络系统上 X.509 证书 X.509证书包含三个文件：key，csr，crt。 • key是服务器上的私钥文件，用于对发送给客户端数据的加密，以及对从客户端接收到数据的解密 • csr是证书签名请求文件，用于提交给证书颁发机构（CA）对证书签名 • crt是由证书颁发机构（CA）签名后的证书，或者是开发者自签名的证书，包含证书持有人的信息，持有人的公钥，以及签署者的签名等信息备注：在密码学中，X.509是一个标准，规范了公开秘钥认证、证书吊销列表、授权凭证、凭证路径验证算法等。 3.CA证书验证流程： HTTPS 实践单项认证第一步：为服务器端准备公钥、私钥1234# 生成服务器端私钥openssl genrsa -out server.key 1024# 生成服务器端公钥openssl rsa -in server.key -pubout -out server.pem 第二步:生成 CSR(证书请求文件)12# 生成 CSR（Certificate Secure Request）openssl req -new -key server.key -out server.csr 123456789101112131415➜ keys openssl req -new -key ca.key -out ca.csrYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:ZhejiangLocality Name (eg, city) []:HangzhouOrganization Name (eg, company) [Internet Widgits Pty Ltd]:My CAOrganizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []:localhostEmail Address []: 注意： 1.上面的Common name可以是域名（IP），或者名字 当是生成服务器端的证书请求文件： commmon name要和自己的网站域名一致 当是生成客户端的证书请求文件时,写成自己的名字或者域名都行 2.这里的 Organization Name (eg, company) [Internet Widgits Pty Ltd]: 后面生成客户端和服务器端证书的时候也需要填写，不要写成一样的！！！可以随意写如：My CA, My Server, My Client 第三步：生成CA证书1).使用自己的私钥作为CA进行自签名12# server.key 作为CA的私钥进行CA签名openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt 2).使用不受操作系统信任的CA机构进行CA签名12345678910 1. 生成CA证书# 生成 CA 私钥openssl genrsa -out ca.key 1024# X.509 Certificate Signing Request (CSR) Management.openssl req -new -key ca.key -out ca.csr# X.509 Certificate Data Management. CA机构向上一级CA机构签名提供证书请求文件.csr和 上一级机构的私钥 .key文件生成 签名证书.crtopenssl x509 -req -in ca.csr -signkey ca.key -out ca.crt 2. CA机构 使用自己的 上级机构生成的证书 ca.crt和 自己的私钥 ca.key对证书请求文件进行签名# 向自己的 CA 机构申请证书，签名过程需要 CA 的证书和私钥参与，最终颁发一个带有 CA 签名的证书openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crt 此时，我们的keys文件夹目录如下 123456789101112.├── https-server.js└── keys ├── ca.crt ├── ca.csr ├── ca.key ├── ca.pem ├── ca.srl ├── server.crt ├── server.csr ├── server.key └── server.pem 3). 将证书签名文件 server.csr 交给CA机构进行CA签名，步奏和上面第二种方案一样，唯一区别是ca.crt和ca.key是正式的CA机构的HTTPS单项认证服务器端测试代码：1234567891011// file http-server.jsvar https = require('https');var fs = require('fs');var options = &#123; key: fs.readFileSync('./keys/server.key'), cert: fs.readFileSync('./keys/server.crt')&#125;;https.createServer(options, function(req, res) &#123; res.writeHead(200); res.end('hello world');&#125;).listen(8000); HTTPS单线认证缺点： 容易遭受第三方（ 中间人）攻击例如： 使用代理作为中间人进行抓包截取数据 curl -k https://localhost:8000 可以获取服务器的数据双向认证单项认证只有客户端对服务器端的认证，没有服务器端对客户端的认证双向认证不仅需要服务器对客户端身份的认证，也需要客户端对服务器端身份的认证第一步：为服务器端和客户端准备公钥、私钥12345678# 生成服务器端私钥openssl genrsa -out server.key 1024# 生成服务器端公钥openssl rsa -in server.key -pubout -out server.pem# 生成客户端私钥openssl genrsa -out client.key 1024# 生成客户端公钥openssl rsa -in client.key -pubout -out client.pem 第二步:生成 CSR(证书请求文件)1234# 服务器生成 CSR（Certificate Secure Request）openssl req -new -key server.key -out server.csr# client 端openssl req -new -key client.key -out client.csr 第三步：生成CA证书 利于前面已生成的CA 机构的 私钥和签名证书对 服务端和客户端的 证书请求文件进行签名1234# 向自己的 CA 机构申请证书，签名过程需要 CA 的证书和私钥参与，最终颁发一个带有 CA 签名的证书openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crt# client 端到 CA 签名openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in client.csr -out client.crt 此时，我们的 keys 文件夹下已经有如下内容了 12345678910111213141516├── https-client.js├── https-server.js└── keys ├── ca.crt ├── ca.csr ├── ca.key ├── ca.pem ├── ca.srl ├── client.crt ├── client.csr ├── client.key ├── client.pem ├── server.crt ├── server.csr ├── server.key └── server.pem HTTPS双项认证服务器端测试代码和单项认证一样,客户端代码如下：1234567891011121314151617181920212223// file http-client.jsvar https = require('https');var fs = require('fs');var options = &#123; hostname: \"localhost\", port: 8000, path: '/', methed: 'GET', key: fs.readFileSync('./keys/client.key'), cert: fs.readFileSync('./keys/client.crt'), ca: [fs.readFileSync('./keys/ca.crt')]&#125;;options.agent = new https.Agent(options);var req = https.request(options, function(res) &#123; res.setEncoding('utf-8'); res.on('data', function(d) &#123; console.log(d); &#125;);&#125;);req.end();req.on('error', function(e) &#123; console.log(e);&#125;); 先打开服务器 node http-server.js，然后执行 12node https-client.jshello world 遇见的问题保存： ‘DEPTH_ZERO_SELF_SIGNED_CERT’ 由于HTTPS服务器会对客户端的证书进行验证，而客户端的证书是自签的证书，不是CA机构办法的，固然操作系统的根证书验证通不过 需要将rejectUnauthorized:false 告诉服务器不要进行根证书列表的验证 同时将ca: [fs.readFileSync(‘./keys/ca.crt’)], 以保证数据双向传输的安全 创建多域名的HTTPS证书 (openssl证书添加多个域名) 前面讲了如何使用openssl创建单域名的证书：CA机构中的csr 请求文件中的Commmon Name(域名) 必须设置一致。这个是有问题的，客户端和服务器设置的域名大多数情况下，是不一样的，这个时候客户端请求服务器时，就会报我们请求的域名不在证书列表中的错误。因此 就需要我们创建的 CA证书必须是支持多域名的 我们前面使用的是openssl默认的CA，由于 openssl自建CA默认签署的是单域名证书，所以我们需要创建自己的CA来支持CA证书中国包含多个HTTPS的域名。具体方案如下： 一 修改opensslcnf 在linux/Unix 查找opensslcnf文件的位置的命令： find / -name openssl.cn 在Mac 上需要超级用户的权限 Mac上文件的位置：/System/Library/OpenSSL/openssl.cnf 找到openssl 后拷贝一份，放在前面证书keys的目录下(创建自己的CA和系统CA分开，放在不同的目录)，修改我们拷贝过来的openssl1234567891011121314151617181920212223242526272829303132333435363738394041424344# 确保req下存在以下2行（默认第一行是有的，第2行被注释了,在这里放开） [ req ]distinguished_name = req_distinguished_namereq_extensions = v3_req# 确保req_distinguished_name下没有 0.xxx 的标签，有的话把0.xxx的0. 去掉[ req_distinguished_name ]countryName = Country Name (2 letter code)countryName_default = AUcountryName_min = 2countryName_max = 2stateOrProvinceName = State or Province Name (full name)stateOrProvinceName_default = Some-StatelocalityName = Locality Name (eg, city)organizationName = Organization Name (eg, company)organizationName_default = Internet Widgits Pty Ltd# we can do this but it is not needed normally :-)#1.organizationName = Second Organization Name (eg, company)#1.organizationName_default = World Wide Web Pty LtdorganizationalUnitName = Organizational Unit Name (eg, section)#organizationalUnitName_default =commonName = Common Name (e.g. server FQDN or YOUR name)commonName_max = 64emailAddress = Email AddressemailAddress_max = 64# 在v3_req新增最后一行内容 subjectAltName = @alt_names（前2行默认存在）[ v3_req ]# Extensions to add to a certificate requestbasicConstraints = CA:FALSEkeyUsage = nonRepudiation, digitalSignature, keyEnciphermentsubjectAltName = @alt_names# 新增 alt_names,注意括号前后的空格，DNS.x 的数量可以自己加[alt_names]DNS.1 = localhostDNS.2 = yuanmenglong.cnDNS.3 = localhostIP.1 = 127.0.0.1IP.2 = 10.252.57.52 二 创建自己的CA目录 由于前面使用的系统的配置文件openssl.cnf生成的CA机构，所以只支持单域名，这里我们需要使用刚刚修改过的openssl.cnf 来创建新的CA机构（和系统不一样，这个支持多域名哈） （openssl.cnf中会要求部分文件及目录存在 在shell下创建如下目录12345678910# 建立CA目录结构[root@localhost]#mkdir -p CA/&#123;certs,crl,newcerts,private&#125;[root@localhost]# touch CA/index.txt[root@localhost]#echo 00 &gt; CA/serial # 生成CA的私钥 openssl genrsa -out ./CA/private/ca.key 1024,# 生成CA机构的 .csr证书颁发文件 这里需要用到自己修改过的oenssl.cnf ，来进行请求颁发证书的配制 openssl req -new -key ./CA/private/ca.key -out ca.csr -extensions v3_req -config ./openssl.cnf# 生成自签发的CA证书 x509 -req -in ca.csr -signkey ./CA/private/ca.key -out ca.crt 三 多域名测试#双向认证时，重新生成客户端的 请求证书颁发文件： 域名写成 和服务器不一样例如： 服务器为：10.252.57.52 ，客户端则为：localhost，但是必须在上面的配置文件[alt_names] 下的DNS.x和IP.x的列表中 openssl req -new -key client.key -out client.csr #对服务器的证书使用新的CA证书和私钥重新签名 openssl x509 -req -CA ca.crt -CAkey ./CA/private/ca.key -CAcreateserial -in server.csr -out server.crt #对客户端的证书使用新的CA证书和私钥重新签名 openssl x509 -req -CA ca.crt -CAkey ./CA/private/ca.key -CAcreateserial -in client.csr -out client.crt # 查看证书具体信息的命令： openssl rsa -noout -text -in server.key 查看私钥信息 openssl req -noout -text -in server.csr 查看签名请求信息 openssl rsa -noout -text -in ca.key 查看ca的私钥信息 openssl x509 -noout -text -in ca.crt 查看证书信息 openssl crl -text -in xx.crl 查看一个证书吊销列表信息 至此我们支持多域名的HTTPS证书就创建成功啦","tags":[]},{"title":"客户端回滚机制","date":"2017-06-20T13:10:30.000Z","path":"2017/06/20/客户端回滚机制/","text":"业务场景： 某一次客户端的上线，可能由于场景的原因或者其他原因导致 用户在某一种业务场景下，App大批量的崩溃，以至于影响用户的正常使用，为了解决情况，客户端继续引入一种解决方案——客户端回滚机制 回滚机制： 说白了就是在一部分用户使用线上版本大批量的崩溃，且无法使用热修复来快速解决这些崩溃，影响这些用户正常使用时，我们需要让这批用户切回到上一个版本，不影响他们目前的正常使用。当我们的对于线上bug 修复后，又让这批用户切回到我们的最新版本。 回滚原理：1. 客户端将崩溃的日志记录下来，并发送给服务器 2. 上线后RD根据崩溃类型，来进行后台的设置，对某一种类型的崩溃需要版本的回滚 3. 服务器端收到这种类型的崩溃时，给客户端返回新的下载链接，去下载需要回滚的应用包 4. RD在bug 修复后，进行服务器端的设置，来返回无bug的应用。 回滚流程： 总结： 回滚只是一种机制，在线上迫不得已的情况下使用，目的只是为了不影响某些机型，某些场景下用户的体验和使用，来提高用户的体验","tags":[{"name":"移动端","slug":"移动端","permalink":"http://yuanmenglong.cn/tags/移动端/"}]}]